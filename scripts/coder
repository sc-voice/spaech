#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const assert = require('assert')
const { logger } = require('log-instance');
const tf = require('@tensorflow/tfjs-node');
const { WaveFile } = require('wavefile');
const {
  Chart,
  AutoEncoder,
  Signal,
} = require('../index');

function help() {
    console.log(`
NAME
        coder - compress/expand audio 

SYNOPSIS
        coder [OPTIONS] 
        coder --signal-in TRAIN_WAV --model-path MODEL_PATH --train
        coder --signal-in SRC_WAV --model-path MODEL_PATH --signal-out DST_WAV

DESCRIPTION
        Transform audio signals with an auto-encoder neural net
        with snake activation layers (https://arxiv.org/pdf/2006.08195.pdf).
        Auto-encoders are designed to compress their input, so an
        auto-encoder can be used to compress and/or expand signals.
        Essentially, the neural net itself has information about all
        signals from a given source for which the net has been trained.
        The compressed signal therefore does not need to transmit the
        information in the neural net and can transfer far less information
        for any signal from that source. Auto-encoders work best for
        signals from a single, consistent source. For arbitrary signals
        from arbitrary sources, they offer no advantage over existing
        audio compression algorithms such as MP3. However, for signals
        coming from a single, consistent source, they provide higher
        compression ratios.

    -cl, --chart-lines N
        Number of lines used to chart worst signal mismatch (15)

    -cs, --code-size
        Number of units in the bottleneck code layer.

    -du, --decoder-units N1,N2,...,NN
        Number of units in each decoder layer: (reverse of encoderUnits)

    -ep, --epochs
        Training epochs (100)

    -ie, --initial-epoch EPOCH
        Initial epoch for continued training

    -le, --log-epoch N
        Log training stats every every N epochs (10)

    -el, --encoder-layers N
        Number of encoder/decoder layers (3)

    -eu, --encoder-units N1,N2,...,NN
        Number of units in each encoder layer: 
        [frameSize, frameSize, frameSize/2, frameSize/3, frameSize/5]

    -ea, --encoder-alpha A
    -ea, --encoder-alpha A1,A2,...,AN 
        Snake activation frequency coefficient. Either a list of alpha
        coefficients (one for each layer), or a single number. A single
        alpha number will be used to generate an alpha for each
        encoder/decoder layer. The default is the Golden Ratio.

    -fs, --frame-size
        Audio is encoded/decoded by consecutive frames of given size. (192)

    -?, --help
        Print help

    -ll, --log-level
        Logging level: warn, error, [info], debug

    -mp, --model-path MODEL_FOLDER
    -mp, --model-path URL
        JSON resource URL or local file path (test/model/coder)

    -ro, --residual-out WAV_FILE
        Output residual of signal minus tranformed signal.
        
    -sc, --scale SCALE
        Signal normalization (16384)

    -si, --signal-in WAV_FILE
        Input signal

    -so, --signal-out WAV_FILE
        Output signal

    -ta, --train-attempts N
        Train code with up to N attempts to save a better model (1)

    -tr, --train  
        Train coder using input signal
`);
    process.exit(0);
}

const TEST_DATA_DIR = path.join(path.dirname(__dirname), 'test/data');
const EVAM_ME_SUTTAM_WAV = path.join(TEST_DATA_DIR, 'evam-me-suttam.wav');
const AN9_20_4_3_WAV = path.join(TEST_DATA_DIR, 'an9.20_4.3.wav');
const argv = process.argv;
const script = argv[1].split('/').pop();

var cmdCfg = {};

var nargs = process.argv.length;
if (nargs < 3) {
    help();
}
for (var i = 2; i < nargs; i++) {
  var arg = process.argv[i];
  if (i<2) { continue; }
  if (arg === '-?' || arg === '--help') {
    help();
  } else if (arg === '-du' || arg === '--decoder-units') {
    cmdCfg.decoderUnits = argv[++i].split(',').map(v=>Math.max(1, Math.round(Number(v))));
  } else if (arg === '-ea' || arg === '--encoder-alpha') {
    cmdCfg.encoderAlpha = argv[++i].split(',').map(v=>Number(v));
    if (cmdCfg.encoderAlpha.length === 1) { cmdCfg.encoderAlpha = cmdCfg.encoderAlpha[0]; }
  } else if (arg === '-le' || arg === '--log-epoch') {
    cmdCfg.logEpoch = Number(argv[++i]);
  } else if (arg === '-el' || arg === '--encoder-layers') {
    cmdCfg.encoderLayers = Number(argv[++i]);
  } else if (arg === '-eu' || arg === '--encoder-units') {
    cmdCfg.encoderUnits = argv[++i].split(',').map(v=>Math.max(1, Math.round(Number(v))));
  } else if (arg === '-sc' || arg === '--scale') {
    cmdCfg.scale = Number(argv[++i]);
  } else if (arg === '-ep' || arg === '--epochs') {
    cmdCfg.epochs = Number(argv[++i]);
  } else if (arg === '-ie' || arg === '--initial-epoch') {
    cmdCfg.initialEpoch = Number(argv[++i]);
  } else if (arg === '-mp' || arg === '--model-path') {
    cmdCfg.modelPath = argv[++i];
  } else if (arg === '-cl' || arg === '--chart-lines') {
    cmdCfg.chartLines = Number(argv[++i]);
  } else if (arg === '-ta' || arg === '--train-attempts') {
    cmdCfg.trainAttempts = Number(argv[++i]);
  } else if (arg === '-cs' || arg === '--code-size') {
    cmdCfg.codeSize = Number(argv[++i]);
  } else if (arg === '-fs' || arg === '--frame-size') {
    cmdCfg.frameSize = Number(argv[++i]);
  } else if (arg === '-ro' || arg === '--residual-out') {
    cmdCfg.residualOut = argv[++i];
  } else if (arg === '-si' || arg === '--signal-in') {
    cmdCfg.signalIn = argv[++i];
  } else if (arg === '-so' || arg === '--signal-out') {
    cmdCfg.signalOut = argv[++i];
  } else if (arg === '-tr' || arg === '--train') {
    cmdCfg.trainModel = true;
  } else if (arg === '-ll' || arg === '--log-level') {
    cmdCfg.logLevel = logger.logLevel = argv[++i];
  } else {
    throw logger.error('E_UNKNOWN_OPTION', `Unknown option: ${argv[i]}`);
  }
}

async function wavSignal(fnam=EVAM_ME_SUTTAM_WAV) {
  assert(fnam, `Expected signal file path`);
  let buf = await fs.promises.readFile(fnam);
  let wf = new WaveFile(buf);
  return new Signal(wf.getSamples(false, Int16Array));
}

function normalizeUrl(urlOrPath) {
  if (urlOrPath == null) {
    throw logger.error('E_MODEL_PATH', `Model url or path is required: -mp PATH`);
  }
  if (/^[a-z]*:/.test(urlOrPath)) {
    return urlOrPath;
  } 

  var url = path.join(process.cwd(), urlOrPath);
  return `file:////${url}`;
}

function configuration(cfg=cmdCfg) {
  return Object.assign({}, {
    chartLines: 15,
    epochs: 100,
    scale: 16384,
    signalIn: EVAM_ME_SUTTAM_WAV,
    signalOut: undefined,
    trainModel: false,
    frameSize: 192,
    codeSize: 6,
    logLevel: 'info',
    verbose: false,
    encoderLayers: 3,
    encoderUnits: 0.8,
    encoderAlpha: 1.61803398875,
    decoderUnits: undefined,
    initialEpoch: 0,
    trainAttempts: 1,
    modelPath: 'test/model/coder',
  }, cfg);
}

async function loadModel(modelPath) {
  let modelUrl = normalizeUrl(modelPath);
  let coder;
  let savedModel;
  if (modelUrl) {
    try {
      savedModel = await tf.loadLayersModel(`${modelUrl}/model.json`);
      logger.info(`loaded model:${modelUrl}`);
    } catch(e) { 
      logger.info(`cannot load model:${modelUrl}`);
    }
  }
  if (savedModel) {
    let savedCfg = AutoEncoder.modelConfiguration(savedModel);
    Object.keys(savedCfg).forEach(key=>{
      if (cmdCfg.hasOwnProperty(key)) {
        let savedVal = savedCfg[key];
        let cmdVal = cmdCfg[key];
        if (savedVal !== cmdCfg[key]) {
          logger.info(`savedModel.${key}:${savedVal} overrides command option: ${cmdVal}`);
        }
      }
    });
    savedCfg.model = savedModel;
    coder = new AutoEncoder(savedCfg);
  }
  return {
    modelUrl,
    savedModel,
    coder,
  }
}

async function chartWorst({model, frames, stats, chartLines}) {
  let { iMax, max, avg }  = stats;
  let xtest = tf.tensor2d(frames.slice(iMax,iMax+1));
  let ytest = await model.predict(xtest);
  let chart = new Chart();
  chart.plot({
    data: [[...xtest.dataSync()],[...ytest.dataSync()]], 
    title:`Worst frame:${iMax} mse:${max} mseAvg:${avg} 1:expected 2:actual`,
    lines: chartLines,
  });
}

async function writeSignal(fpath, signal) {
  let wav = signal.toWav();
  try {
    await fs.promises.writeFile(fpath, wav);
    logger.info(`writing signal: ${fpath} (${wav.length})`);
  } catch(e) {
    throw logger.error(`Could not write: ${fpath}`, e.message);
  }
}

(async function() {
  let cfg = configuration(cmdCfg);
  let { 
    modelPath, 
    trainModel, 
    residualOut,
    signalIn, 
    signalOut,
    epochs, 
    initialEpoch, 
    logEpoch, 
    chartLines,
    trainAttempts,
  } = cfg;
  logger.info(script, argv.slice(2).join(' '));
  let { coder, modelUrl, savedModel } = await loadModel(modelPath);
  let sigIn = await wavSignal(signalIn);
  logger.info(`signal in: ${sigIn.data.length} samples ${signalIn}`);

  if (coder == null) {
    logger.info(`creating AutoEncoder`, cfg);
    coder = new AutoEncoder(cfg);
  }
  let { model } = coder;
  model.summary();
  let { splits, frames } = coder.frameSignal(sigIn);
  let statsSigIn = await coder.validateSignal(sigIn);

  // Train
  if (trainModel) {
    let save = 0;
    for (let iTrain=1; !save && iTrain <= trainAttempts; iTrain++) {
      logger.info(`training model (attempt #${iTrain}/${trainAttempts})...`);
      let msStart = Date.now();
      let resTrained = trainModel && (await coder.train({frames, epochs, initialEpoch, logEpoch}));
      let msElapsed = Date.now() - msStart;
      var statsTrained = await coder.validateSignal(sigIn);
      logger.debug(`trained stats`, statsTrained);
      await chartWorst({model, frames, stats:statsTrained, chartLines});
      logger.debug(`current stats`, statsSigIn);
      logger.info(`current mse:`, statsSigIn.avg);
      logger.info(`trained mse: ${statsTrained.avg} elapsed:${(msElapsed/1000).toFixed(2)}s`);
      if (savedModel !== model) {
        logger.info(`saving new model#${iTrain} => ${modelUrl}`);
        save = iTrain;
      } else if (statsTrained && statsTrained.avg < statsSigIn.avg) {
        logger.info(`saving better model#${iTrain} => ${modelUrl}`);
        save = iTrain;
      } else {
        logger.info(`trained model not saved (mseSaved <= mseCurrent)`);
      } 
    }
    if (save) {
      model.save(modelUrl);
    } else {
      logger.info(`Could not train better model after ${trainAttempts} attempts`);
    }
  } else {
    logger.info(`no changes made to trained model`);
    await chartWorst({model, frames, stats:statsSigIn, chartLines});
  }

  let sigOut;
  if (signalOut) {
    sigOut = sigOut || coder.transform(sigIn);
    await writeSignal(signalOut, sigOut);
  }

  if (residualOut) {
    let { data:dataOut } = sigOut || coder.transform(sigIn);
    let { data:dataIn } = sigIn;
    let dataRes = new Int16Array(dataOut.length);
    for (let i=0; i < dataOut.length; i++) {
      dataRes[i] = dataIn[i] - dataOut[i];
    }
    let sigRes = new Signal(dataRes);
    await writeSignal(residualOut, sigRes);
  }
})();
